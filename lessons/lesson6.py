# 1. Что такое Big O нотация?
# Определение
# Big O нотация используется для описания производительности алгоритма
# измеряемой как:
# (Time complexity) Оценивает, как количество операций, выполняемых алгоритмом,
# зависит от размера входных данных
# (Space complexity) Оценивает сколько памяти (RAM) требуется алгоритму для выполнения
# в зависимости от размера входных данных

# Основные понятия:
# O(1): Константное время - выполнение алгоритма не зависит от размера данных.
# O(10g n): Логарифмическое время - время выполнения растёт пропорционально логарифму от количества данных.
# O(n): Линейное время - время выполнения увеличивается линейно от роста входных данных.
# O(n^2): Квадратичное время - время выполнения растёт пропорционально квадрату размера данных.
# O(2^n): Экспоненциальное время - рост входных данных приводит к экспоненциально росту времени выполнения.


# O(1):
# def get_first_element(data):
#     return data[0]
#
# data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# print(get_first_element(data))


# O(n):
# def sum_element(data):
#     result = 0
#     for element in data:
#         result += element
#     return result
#
# data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# print(sum_element(data))


# O(n^2):
# def print_pairs(data):
#     for i in range(len(data)):
#         for j in range(len(data)):
#             print(data[i], data[j])
#
# data = [1, 2, 3]
# print_pairs(data)


# 2. Что такое рекурсия?
# Рекурсия - это метод, при котором функция вызывает саму себя для решения задачи.
# Рекурсивные функции обязательно должны иметь:

# 1. Базовый случай (base case) - условие завершение рекурсии.
# 2. Рекурсивный случай - разбиение задачи на подзадачи


# Пример: Факториал
# Факториал числа n (n!) - это произведение натуральных чисел от 1 до n.

# def factorial(n):
#     if n == 0: # Базовый случай
#         return 1
#     else:
#         return n * factorial(n-1) # рекурсивный случай 5 * 4 * 3 * 2 * 1
#
# print(factorial(5))


# Пример: Фибоначчи

# def fibonacci(n):
#     if n == 0: # Базовый члучай
#         return 0
#     elif n == 1:
#         return 1
#     else:
#         return fibonacci(n-1) + fibonacci(n-2) # рекурсивный случай
#
# print(fibonacci(6))